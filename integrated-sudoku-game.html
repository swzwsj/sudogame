<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卡通数独 - 休闲益智游戏</title>
    <!-- 自定义CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- 主容器 -->
    <div class="container">
        <!-- 标题 -->
        <header class="text-center mb-6">
            <h1 class="text-4xl md:text-5xl font-bold text-primary mb-2">卡通数独</h1>
            <p class="text-xl text-secondary">挑战你的逻辑思维能力！</p>
        </header>
        
        <!-- 游戏控制面板 -->
        <div class="game-controls flex flex-wrap justify-between items-center mb-6 bg-light rounded-lg p-4 border-handdrawn shadow-handdrawn">
            <!-- 主题切换 -->
            <button id="theme-toggle" class="btn btn-secondary">
                <i class="fa fa-moon-o mr-2"></i>切换主题
            </button>
            
            <!-- 难度选择器 -->
            <div class="flex flex-wrap align-center gap-2">
                <label class="text-lg font-bold">难度:</label>
                <div id="level-selector" class="level-selector gap-1">
                    <!-- 动态生成关卡选择按钮 -->
                </div>
            </div>
            
            <!-- 游戏控制按钮 -->
            <div class="flex flex-wrap gap-2">
                <button id="btn-hint" class="btn btn-accent">
                    <i class="fa fa-lightbulb-o mr-2"></i>提示 (3)
                </button>
                <button id="btn-clear" class="btn btn-dark">
                    <i class="fa fa-eraser mr-2"></i>清除
                </button>
                <button id="btn-reset" class="btn btn-dark">
                    <i class="fa fa-refresh mr-2"></i>重置
                </button>
                <button id="btn-rules" class="btn btn-dark">
                    <i class="fa fa-question-circle mr-2"></i>规则
                </button>
            </div>
        </div>
        
        <!-- 数独网格 -->
        <div class="flex justify-center mb-6">
            <div id="sudoku-grid" class="sudoku-grid"></div>
        </div>
        
        <!-- 数字选择面板 -->
        <div id="number-pad" class="number-pad"></div>
        
        <!-- 游戏信息面板 -->
        <div class="game-info bg-light rounded-lg p-4 border-handdrawn shadow-handdrawn text-center mb-6">
            <div id="timer"></div>
            <div id="best-time"></div>
        </div>
        
        <!-- 完成消息 -->
        <div id="completion-message" class="modal hidden">
            <div class="modal-content">
                <h2 class="text-2xl font-bold text-primary mb-4">恭喜完成！</h2>
                <p class="text-lg mb-6">你成功解决了这个数独谜题！</p>
                <button id="next-level-btn" class="btn btn-primary">
                    下一关
                </button>
            </div>
        </div>
        
        <!-- 规则说明模态框 -->
        <div id="rules-modal" class="modal hidden">
            <div class="modal-content">
                <h2 class="text-2xl font-bold text-primary mb-4">数独规则</h2>
                <ul class="text-left mb-6 space-y-2">
                    <li>1. 在9x9的网格中填入数字1-9</li>
                    <li>2. 每行、每列和每个3x3的小方格中不能有重复数字</li>
                    <li>3. 点击空白单元格，然后点击数字面板上的数字填入</li>
                    <li>4. 使用提示功能获取帮助（有限次数）</li>
                    <li>5. 挑战不同难度级别，提升你的逻辑思维能力！</li>
                </ul>
                <button id="close-rules" class="btn btn-primary">
                    了解了
                </button>
            </div>
        </div>
        
        <!-- 加载提示 -->
        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="loading-content">
                <h2 class="text-2xl font-bold text-primary mb-6 text-center">生成谜题中...</h2>
                <div class="progress-bar mb-4">
                    <div id="loading-bar" class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="loading-message" class="text-center">准备生成谜题...</p>
                <button id="cancel-loading" class="mt-6 w-full btn btn-dark hidden">
                    取消加载
                </button>
            </div>
        </div>
    </div>
    
    <!-- 数独核心模块 -->
    <script src="sudoku-core.js"></script>
    
    <!-- 游戏主逻辑 -->
    <script>
        // 初始化数独求解器 - 修复引用错误
        class SudokuSolver {
            constructor() {}
            
            solveGrid(grid) {
                return SudokuCore.solveGrid(grid);
            }
            
            isValid(grid, row, col, num) {
                return SudokuCore.isValidPlacement(grid, row, col, num);
            }
        }
        
        const sudokuSolver = new SudokuSolver();
        
        // 专门的关卡配置
        const levelConfigs = {
            1: { difficulty: 'easy', timeout: 5000 },
            2: { difficulty: 'medium', timeout: 8000 },
            3: { difficulty: 'hard', timeout: 10000 },
            4: { difficulty: 'expert', timeout: 12000 },
            5: { difficulty: 'master', timeout: 15000 }
        };

        // 游戏状态
        const gameState = {
            theme: localStorage.getItem('sudokuTheme') || 'light',
            currentLevel: 1,
            maxLevel: 5,
            puzzle: [], // 用户看到的谜题
            solution: [], // 解决方案
            userGrid: [], // 用户填写的内容
            hintsRemaining: 3,
            selectedCell: null,
            isCompleted: false,
            startTime: null,
            timerInterval: null,
            bestTimes: JSON.parse(localStorage.getItem('sudokuBestTimes')) || {},
            generatingPuzzle: false,
            progress: 0,
            generationTimeout: null
        };
        
        // 初始化主题
        function initTheme() {
            document.documentElement.classList.remove('theme-light', 'theme-dark');
            document.documentElement.classList.add(`theme-${gameState.theme}`);
            const themeIcon = document.querySelector('#theme-toggle i');
            themeIcon.className = gameState.theme === 'dark' ? 'fa fa-sun-o' : 'fa fa-moon-o';
        }
        
        // 切换主题
        function toggleTheme() {
            gameState.theme = gameState.theme === 'light' ? 'dark' : 'light';
            localStorage.setItem('sudokuTheme', gameState.theme);
            initTheme();
        }
        
        // 预定义所有关卡的谜题模式，确保加载速度和稳定性
        const puzzlePatterns = {
            1: [
                [5,3,0,0,7,0,0,0,0],
                [6,0,0,1,9,5,0,0,0],
                [0,9,8,0,0,0,0,6,0],
                [8,0,0,0,6,0,0,0,3],
                [4,0,0,8,0,3,0,0,1],
                [7,0,0,0,2,0,0,0,6],
                [0,6,0,0,0,0,2,8,0],
                [0,0,0,4,1,9,0,0,5],
                [0,0,0,0,8,0,0,7,9]
            ],
            2: [
        [0,0,4,6,0,0,0,0,0],
        [0,0,0,0,7,5,0,0,0],
        [0,0,0,0,0,1,0,7,9],
        [0,7,0,8,0,0,0,1,0],
        [0,0,2,0,4,0,8,0,0],
        [0,6,0,0,0,2,0,5,0],
        [9,2,0,1,0,0,0,0,0],
        [0,0,0,3,2,0,0,0,0],
        [0,0,0,0,0,9,7,0,0]
    ],
            3: [
                [5,0,0,0,0,0,0,0,0],
                [0,0,3,6,0,0,0,0,0],
                [0,7,0,0,9,0,2,0,0],
                [0,5,0,0,0,7,0,0,0],
                [0,0,0,0,4,5,7,0,0],
                [0,0,0,1,0,0,0,3,0],
                [0,0,1,0,0,0,0,6,8],
                [0,0,8,5,0,0,0,1,0],
                [0,9,0,0,0,0,4,0,0]
            ],
            4: [
                [0,0,0,2,6,0,7,0,1],
                [6,8,0,0,7,0,0,9,0],
                [1,9,0,0,0,4,5,0,0],
                [8,2,0,1,0,0,0,4,0],
                [0,0,4,6,0,2,9,0,0],
                [0,5,0,0,0,3,0,2,8],
                [0,0,9,3,0,0,0,7,4],
                [0,4,0,0,5,0,0,3,6],
                [7,0,3,0,1,8,0,0,0]
            ],
            5: [
                [0,2,0,0,0,0,0,0,0],
                [0,0,0,6,0,0,0,0,3],
                [0,7,4,0,8,0,0,0,0],
                [0,0,0,0,0,3,0,0,2],
                [0,8,0,0,4,0,0,1,0],
                [6,0,0,5,0,0,0,0,0],
                [0,0,0,0,1,0,7,8,0],
                [5,0,0,0,0,9,0,0,0],
                [0,0,0,0,0,0,0,4,0]
            ]
        };
        
        // 更新加载进度
        function updateLoadingProgress(percent, message) {
            gameState.progress = percent;
            document.getElementById('loading-bar').style.width = `${percent}%`;
            if (message) {
                document.getElementById('loading-message').textContent = message;
            }
        }
        
        // 强制隐藏加载提示
        function forceHideLoading() {
            // 使用setTimeout确保即使在复杂的异步环境中也能正确隐藏
            setTimeout(() => {
                gameState.generatingPuzzle = false;
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    // 先移除可能存在的显示相关类，然后添加隐藏类
                    loadingOverlay.classList.remove('block', 'flex', 'visible');
                    loadingOverlay.classList.add('hidden');
                    // 直接设置style确保CSS优先级问题不会影响隐藏
                    loadingOverlay.style.display = 'none';
                }
                const cancelButton = document.getElementById('cancel-loading');
                if (cancelButton) {
                    cancelButton.classList.add('hidden');
                    cancelButton.style.display = 'none';
                }
                
                // 清除超时计时器
                if (gameState.generationTimeout) {
                    clearTimeout(gameState.generationTimeout);
                    gameState.generationTimeout = null;
                }
            }, 0);
        }
        
        // 游戏初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 使用新的核心模块
            const difficulty = 'easy'; // 可以根据需要更改难度
            const { puzzle, solution } = SudokuCore.generateSudokuPuzzle(difficulty);

            // 初始化游戏界面
            initializeGame(puzzle, solution);
        });

        function initializeGame(puzzle, solution) {
            // 初始化主题
            initTheme();
            
            // 创建数字面板
            createNumberPad();
            
            // 创建关卡选择器
            createLevelSelector();
            
            // 添加主题切换事件
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            
            // 添加取消加载按钮事件
            document.getElementById('cancel-loading').addEventListener('click', cancelLoading);
            
            // 添加事件监听
            addEventListeners();
            
            // 初始化游戏状态
            gameState.puzzle = puzzle;
            gameState.solution = solution;
            gameState.userGrid = JSON.parse(JSON.stringify(puzzle));
            gameState.hintsRemaining = 3;
            gameState.selectedCell = null;
            gameState.isCompleted = false;
            
            // 批量更新UI
            renderSudokuGrid();
            updateHintButton();
            startTimer();
            updateBestTimeDisplay();
            
            // 添加安全机制
            setTimeout(() => {
                if (gameState.generatingPuzzle) {
                    console.log("安全机制：强制隐藏加载提示");
                    forceHideLoading();
                }
            }, 15000);
        }
        
        // 初始化备用游戏（当主加载失败时）
        function initFallbackGame() {
            gameState.puzzle = JSON.parse(JSON.stringify(puzzlePatterns[1]));
            gameState.solution = JSON.parse(JSON.stringify(gameState.puzzle));
            sudokuSolver.solveGrid(gameState.solution);
            gameState.userGrid = JSON.parse(JSON.stringify(gameState.puzzle));
            renderSudokuGrid();
            updateHintButton();
        }
        
        function createNumberPad() {
    const numberPad = document.getElementById('number-pad');
    if (!numberPad) return;

    // 使用DocumentFragment批量创建DOM元素，减少重排重绘
    const fragment = document.createDocumentFragment();

    for (let i = 1; i <= 9; i++) {
        const button = document.createElement('button');
        button.className = 'btn btn-light';
        button.textContent = i;
        button.dataset.number = i;
        fragment.appendChild(button);
    }

    // 一次性添加所有元素到DOM
    numberPad.appendChild(fragment);

    // 使用事件委托处理数字按钮点击，减少事件监听器数量
    numberPad.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-number]');
        if (button) {
            const number = parseInt(button.dataset.number, 10);
            handleNumberSelection(number);
        }
    });
}
        
        // 创建关卡选择器
        function createLevelSelector() {
            const levelSelector = document.getElementById('level-selector');
            if (!levelSelector) return;

            // 使用DocumentFragment批量创建DOM元素，减少重排重绘
            const fragment = document.createDocumentFragment();

            for (let i = 1; i <= gameState.maxLevel; i++) {
                const button = document.createElement('button');
                button.className = `btn ${i === 1 ? 'btn-primary' : 'btn-dark'}`;
                button.textContent = i;
                button.dataset.level = i;
                fragment.appendChild(button);
            }

            // 一次性添加所有元素到DOM
            levelSelector.appendChild(fragment);

            // 使用事件委托处理关卡按钮点击，减少事件监听器数量
            levelSelector.addEventListener('click', (e) => {
                const button = e.target.closest('button[data-level]');
                if (button && !gameState.generatingPuzzle) {
                    const level = parseInt(button.dataset.level, 10);
                    if (level !== gameState.currentLevel) {
                        gameState.currentLevel = level;
                        updateLevelButtons();
                        generateLevel(level);
                    }
                }
            });

            // 添加一个最终的保险措施，确保加载提示一定会被隐藏
            setTimeout(() => {
                if (document.getElementById('loading-overlay') && 
                    !document.getElementById('loading-overlay').classList.contains('hidden')) {
                    console.log('保险措施: 强制隐藏加载提示');
                    forceHideLoading();
                }
            }, 3000);
        }
        
        // 更新关卡按钮状态
function updateLevelButtons() {
    const buttons = document.querySelectorAll('#level-selector button');
    buttons.forEach(btn => {
        const level = parseInt(btn.dataset.level);
        if (level === gameState.currentLevel) {
            btn.classList.remove('btn-dark');
            btn.classList.add('btn-primary');
        } else {
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-dark');
        }
    });
}
        
        // 添加事件监听器
        function addEventListeners() {
            // 缓存DOM元素引用，避免重复查询
            const btnHint = document.getElementById('btn-hint');
            const btnClear = document.getElementById('btn-clear');
            const btnReset = document.getElementById('btn-reset');
            const btnRules = document.getElementById('btn-rules');
            const closeRules = document.getElementById('close-rules');
            const nextLevelBtn = document.getElementById('next-level-btn');
            const rulesModal = document.getElementById('rules-modal');
            const completionMessage = document.getElementById('completion-message');
            
            // 绑定事件监听器
            if (btnHint) btnHint.addEventListener('click', showHint);
            if (btnClear) btnClear.addEventListener('click', clearSelection);
            
            if (btnReset) {
                btnReset.addEventListener('click', () => {
                    if (!gameState.generatingPuzzle) {
                        generateLevel(gameState.currentLevel);
                    }
                });
            }
            
            if (btnRules && rulesModal) {
                btnRules.addEventListener('click', () => {
                    rulesModal.classList.remove('hidden');
                });
            }
            
            if (closeRules && rulesModal) {
                closeRules.addEventListener('click', () => {
                    rulesModal.classList.add('hidden');
                });
            }
            
            if (nextLevelBtn && completionMessage) {
                nextLevelBtn.addEventListener('click', () => {
                    if (gameState.currentLevel < gameState.maxLevel && !gameState.generatingPuzzle) {
                        gameState.currentLevel++;
                        updateLevelButtons();
                        generateLevel(gameState.currentLevel);
                        completionMessage.classList.add('hidden');
                    }
                });
            }
            
            if (rulesModal) {
                rulesModal.addEventListener('click', (e) => {
                    if (e.target === rulesModal) {
                        rulesModal.classList.add('hidden');
                    }
                });
            }
        }
        
        // 取消加载过程
        function cancelLoading() {
            console.log("用户取消加载");
            forceHideLoading();
            
            // 如果是首次加载失败，使用第一关的预定义谜题作为备选
            if (gameState.puzzle.length === 0) {
                try {
                    initFallbackGame();
                } catch (e) {
                    console.error("使用备选谜题时出错:", e);
                    alert("加载游戏时遇到问题，请刷新页面重试。");
                }
            }
        }
        


        // 开始计时器
        function startTimer() {
            // 清除之前的计时器
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
            
            gameState.startTime = new Date();
            
            // 确保计时器元素存在
            let timerElement = document.getElementById('timer');
            if (!timerElement) {
                timerElement = document.createElement('div');
                timerElement.id = 'timer';
                timerElement.className = 'text-xl font-bold text-primary mt-2';
                const gameControls = document.querySelector('.game-controls');
                if (gameControls) {
                    gameControls.appendChild(timerElement);
                }
            }
            
            // 更新计时器显示
            function updateTimer() {
                if (gameState.isCompleted) return;
                
                const now = new Date();
                const elapsedSeconds = Math.floor((now - gameState.startTime) / 1000);
                
                const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
                const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
                
                timerElement.textContent = `用时: ${minutes}:${seconds}`;
            }
            
            // 立即更新一次
            updateTimer();
            
            // 设置定时器每秒更新一次
            gameState.timerInterval = setInterval(updateTimer, 1000);
        }

        // 停止计时器
        function stopTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }

        // 格式化时间
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}分${remainingSeconds}秒`;
        }

        // 更新最佳时间显示
        function updateBestTimeDisplay() {
            const level = gameState.currentLevel;
            const bestTime = gameState.bestTimes[level] || null;
            
            // 确保元素存在
            let bestTimeElement = document.getElementById('best-time');
            let timerElement = document.getElementById('timer');
            
            if (!bestTimeElement && timerElement) {
                bestTimeElement = document.createElement('div');
                bestTimeElement.id = 'best-time';
                bestTimeElement.className = 'text-lg font-bold text-secondary mt-1';
                timerElement.parentNode.insertBefore(bestTimeElement, timerElement.nextSibling);
            }
            
            if (bestTimeElement) {
                if (bestTime) {
                    bestTimeElement.textContent = `最佳时间: ${formatTime(bestTime)}`;
                } else {
                    bestTimeElement.textContent = '暂无最佳时间';
                }
            }
        }

        // 显示错误模态框
        function showErrorModal(message) {
            // 如果模态框已存在则移除
            const existingModal = document.getElementById('error-modal');
            if (existingModal) {
                document.body.removeChild(existingModal);
            }
            
            const modal = document.createElement('div');
            modal.id = 'error-modal';
            modal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
            modal.innerHTML = `
                <div class="bg-white border-handdrawn border-dark rounded-lg p-6 max-w-md w-full shadow-xl transform transition-all">
                    <h3 class="text-xl font-bold text-accent mb-4">错误</h3>
                    <p class="mb-6">${message}</p>
                    <div class="flex justify-end">
                        <button id="close-error-modal" class="btn-handdrawn bg-primary border-dark text-white py-2 px-4 hover:bg-primary/80 transition-colors">
                            确定
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            document.getElementById('close-error-modal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }

        // 生成指定难度的数独（高度优化版 - 避免游戏卡死）
        function generateLevel(level) {
            // 重置取消加载的状态
            window.loadingCanceled = false;
            
            // 使用专门的关卡配置
            const config = levelConfigs[level] || levelConfigs[3];
            
            // 显示加载提示
            gameState.generatingPuzzle = true;
            gameState.progress = 0;
            
            // 缓存DOM元素引用
            const loadingOverlay = document.getElementById('loading-overlay');
            const cancelButton = document.getElementById('cancel-loading');
            
            if (loadingOverlay && cancelButton) {
                loadingOverlay.classList.remove('hidden');
                cancelButton.classList.remove('hidden');
            }
            
            updateLoadingProgress(10, "准备生成谜题...");
            
            // 清除之前的超时计时器
            if (gameState.generationTimeout) {
                clearTimeout(gameState.generationTimeout);
                gameState.generationTimeout = null;
            }
            
            // 设置新的超时机制，防止无限加载
            gameState.generationTimeout = setTimeout(() => {
                if (!window.loadingCanceled && gameState.generatingPuzzle) {
                    console.warn("生成谜题超时，但仍在处理中...");
                    updateLoadingProgress(95, "处理复杂谜题中，请稍候...");
                    
                    // 为复杂谜题额外增加时间，但避免无限等待
                    setTimeout(() => {
                        if (!window.loadingCanceled && gameState.generatingPuzzle) {
                            console.error("生成谜题超时，已自动为您加载备用谜题。");
                            gameState.generatingPuzzle = false;
                            showErrorModal("生成复杂谜题超时，已自动为您加载备用谜题。");
                            loadFallbackPuzzle(level);
                        }
                    }, 15000); // 额外15秒处理复杂谜题
                }
            }, config.timeout);
            
            // 使用批次处理模式来避免UI阻塞
            const batchProcessor = {
                currentBatch: 0,
                totalBatches: 5,
                startTime: Date.now(),
                maxTimePerBatch: 16, // 约一帧的时间
                
                // 预先分配的网格存储，减少动态内存分配
                puzzleBuffer: null,
                solutionBuffer: null,
                userGridBuffer: null,
                
                initBuffers: function() {
                    // 为每个网格预先分配9x9数组
                    this.puzzleBuffer = new Array(9);
                    this.solutionBuffer = new Array(9);
                    this.userGridBuffer = new Array(9);
                    
                    for (let i = 0; i < 9; i++) {
                        this.puzzleBuffer[i] = new Array(9);
                        this.solutionBuffer[i] = new Array(9);
                        this.userGridBuffer[i] = new Array(9);
                    }
                },
                
                // 高效的网格复制函数，使用预分配的缓冲区
                fastCopyGrid: function(sourceGrid, targetBuffer) {
                    for (let i = 0; i < 9; i++) {
                        for (let j = 0; j < 9; j++) {
                            targetBuffer[i][j] = sourceGrid[i][j];
                        }
                    }
                },
                
                // 执行一批计算
                executeBatch: function() {
                    if (window.loadingCanceled) {
                        forceHideLoading();
                        return;
                    }
                    
                    const batchStartTime = Date.now();
                    
                    try {
                        switch (this.currentBatch) {
                            case 0:
                                // 第一批次：准备数据和缓冲区
                                this.initBuffers();
                                updateLoadingProgress(20, "正在处理谜题数据...");
                                break;
                            
                            case 1:
                                // 第二批次：加载和验证预设谜题
                                if (!puzzlePatterns[level]) {
                                    throw new Error("未找到对应难度的谜题");
                                }
                                
                                // 使用预分配的缓冲区复制数据
                                this.fastCopyGrid(puzzlePatterns[level], this.puzzleBuffer);
                                this.fastCopyGrid(puzzlePatterns[level], this.solutionBuffer);
                                
                                updateLoadingProgress(50, "加载预设谜题...");
                                break;
                            
                            case 2:
                                // 第三批次：求解预定义的谜题以获取完整解
                                const solveResult = sudokuSolver.solveGrid(this.solutionBuffer);
                                
                                if (!solveResult) {
                                    throw new Error("无法求解预定义的谜题");
                                }
                                
                                updateLoadingProgress(70, "准备谜题数据...");
                                break;
                            
                            case 3:
                                // 第四批次：初始化游戏状态
                                this.fastCopyGrid(this.puzzleBuffer, this.userGridBuffer);
                                
                                updateLoadingProgress(90, "准备游戏界面...");
                                break;
                            
                            case 4:
                                // 第五批次：更新UI和完成处理
                                // 初始化游戏状态
                                gameState.userGrid = this.userGridBuffer;
                                gameState.puzzle = this.puzzleBuffer;
                                gameState.solution = this.solutionBuffer;
                                
                                // 重置游戏状态
                                gameState.hintsRemaining = 3;
                                gameState.selectedCell = null;
                                gameState.isCompleted = false;
                                
                                updateLoadingProgress(100, "加载完成！");
                                
                                // 批量更新UI
                                requestAnimationFrame(() => {
                                    // 开始计时
                                    startTimer();
                                    updateBestTimeDisplay();
                                    
                                    renderSudokuGrid();
                                    updateHintButton();
                                    document.getElementById('completion-message').classList.add('hidden');
                                    
                                    // 短暂延迟后隐藏加载提示
                                    setTimeout(() => {
                                        forceHideLoading();
                                    }, 300);
                                });
                                
                                gameState.generatingPuzzle = false;
                                return; // 处理完成
                        }
                    } catch (error) {
                        console.error("生成数独时出错:", error);
                        gameState.generatingPuzzle = false;
                        
                        requestAnimationFrame(() => {
                            showErrorModal(`生成数独时出错: ${error.message}\n将为您加载备用谜题`);
                            loadFallbackPuzzle(level);
                        });
                        return;
                    }
                    
                    // 增加批次计数器
                    this.currentBatch++;
                    
                    // 检查是否执行了过长时间
                    const elapsedTime = Date.now() - batchStartTime;
                    const delayTime = Math.max(0, this.maxTimePerBatch - elapsedTime);
                    
                    // 安排下一批次的执行，给予UI线程喘息的机会
                    setTimeout(() => {
                        requestAnimationFrame(() => this.executeBatch());
                    }, delayTime);
                }
            };
            
            // 启动批次处理器
            requestAnimationFrame(() => {
                batchProcessor.executeBatch();
            });
            
            // 添加一个最终的保险措施，确保加载提示一定会被隐藏
            // 即使其他隐藏逻辑由于某种原因失败
            setTimeout(() => {
                if (loadingOverlay && !loadingOverlay.classList.contains('hidden') && !window.loadingCanceled) {
                    console.log('保险措施: 强制隐藏加载提示');
                    forceHideLoading();
                }
            }, 30000); // 30秒的终极保险
        }
        
        function loadFallbackPuzzle(level) {
    try {
        // 使用优化版的网格深拷贝方法
        const copyGrid = (grid) => grid.map(row => [...row]);
        
        // 选择一个肯定能求解的谜题作为备用（使用第一关的谜题，它已经被验证可以求解）
        const fallbackPuzzle = [
            [5,3,0,0,7,0,0,0,0],
            [6,0,0,1,9,5,0,0,0],
            [0,9,8,0,0,0,0,6,0],
            [8,0,0,0,6,0,0,0,3],
            [4,0,0,8,0,3,0,0,1],
            [7,0,0,0,2,0,0,0,6],
            [0,6,0,0,0,0,2,8,0],
            [0,0,0,4,1,9,0,0,5],
            [0,0,0,0,8,0,0,7,9]
        ];
        
        gameState.puzzle = copyGrid(fallbackPuzzle);
        gameState.solution = copyGrid(gameState.puzzle);
        
        // 使用setTimeout避免立即阻塞UI
        setTimeout(() => {
            try {
                if (sudokuSolver.solveGrid(gameState.solution)) {
                    gameState.userGrid = copyGrid(gameState.puzzle);
                    
                    requestAnimationFrame(() => {
                        renderSudokuGrid();
                        updateHintButton();
                        startTimer();
                        updateBestTimeDisplay();
                        
                        setTimeout(() => {
                            forceHideLoading();
                        }, 300);
                    });
                } else {
                    console.error("无法求解备用谜题，直接使用已知解");
                    // 直接使用已知的解决方案
                    gameState.solution = [
                        [5,3,4,6,7,8,9,1,2],
                        [6,7,2,1,9,5,3,4,8],
                        [1,9,8,3,4,2,5,6,7],
                        [8,5,9,7,6,1,4,2,3],
                        [4,2,6,8,5,3,7,9,1],
                        [7,1,3,9,2,4,8,5,6],
                        [9,6,1,5,3,7,2,8,4],
                        [2,8,7,4,1,9,6,3,5],
                        [3,4,5,2,8,6,1,7,9]
                    ];
                    gameState.userGrid = copyGrid(gameState.puzzle);
                    
                    requestAnimationFrame(() => {
                        renderSudokuGrid();
                        updateHintButton();
                        startTimer();
                        updateBestTimeDisplay();
                        forceHideLoading();
                    });
                }
            } catch (e) {
                console.error("使用备用谜题时出错:", e);
                initFallbackGame();
            }
        }, 100);
    } catch (e) {
        console.error("加载备用谜题时出错:", e);
        initFallbackGame();
    }
}
        
        // 渲染数独网格（高度优化版 - 使用DOM缓存和最小化重排重绘）
        // 缓存DOM元素引用
        let cellCache = [];
        let gridClickHandler = null;
        
        function renderSudokuGrid() {
            const gridContainer = document.getElementById('sudoku-grid');
            if (!gridContainer) return;

            const selectedRow = gameState.selectedCell?.row;
            const selectedCol = gameState.selectedCell?.col;

            // 使用requestAnimationFrame确保UI更新在浏览器重绘前执行
            requestAnimationFrame(() => {
                // 检查是否需要创建新的单元格缓存
                if (cellCache.length === 0) {
                    gridContainer.innerHTML = '';
                    const fragment = document.createDocumentFragment();
                    cellCache = new Array(9).fill(null).map(() => new Array(9).fill(null));

                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            const cell = document.createElement('div');
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            cell.className = 'sudoku-cell';
                            cellCache[row][col] = cell;
                            fragment.appendChild(cell);
                        }
                    }

                    gridContainer.appendChild(fragment);

                    // 添加事件委托处理单元格点击，只添加一次
                    if (!gridClickHandler) {
                        gridClickHandler = (e) => {
                            const cell = e.target.closest('[data-row][data-col]');
                            if (cell && !cell.classList.contains('cursor-default')) {
                                const row = parseInt(cell.dataset.row, 10);
                                const col = parseInt(cell.dataset.col, 10);
                                selectCell(row, col);
                            }
                        };
                        gridContainer.addEventListener('click', gridClickHandler);
                    }
                }

                // 批量更新单元格属性，减少重排
                const updateBatch = [];

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = cellCache[row][col];
                        const value = gameState.puzzle[row][col];
                        const isFixed = value !== 0;
                        const isSelected = row === selectedRow && col === selectedCol;

                        // 重置单元格类名
                        cell.className = 'sudoku-cell';
                        
                        // 添加基本样式类
                        if (isFixed) {
                            cell.classList.add('fixed');
                        } else {
                            cell.classList.add('user-input');
                        }
                        
                        // 添加选中状态
                        if (isSelected) {
                            cell.classList.add('selected');
                        }
                        
                        // 添加3x3区块边框
                        if ((col + 1) % 3 === 0 && col !== 8) {
                            cell.classList.add('sudoku-section');
                        } else {
                            cell.classList.add('sudoku-section-right');
                        }
                        
                        if ((row + 1) % 3 === 0 && row !== 8) {
                            cell.classList.add('sudoku-section');
                        } else {
                            cell.classList.add('sudoku-section-bottom');
                        }

                        updateBatch.push({ cell, value, isFixed });
                    }
                }

                // 使用requestAnimationFrame批量应用更新，减少重绘次数
                requestAnimationFrame(() => {
                    for (let i = 0; i < updateBatch.length; i++) {
                        const { cell, value, isFixed } = updateBatch[i];

                        // 更新内容
                        if (value !== 0) {
                            if (cell.textContent !== value.toString()) {
                                cell.textContent = value;
                            }
                        } else if (cell.textContent !== '') {
                            cell.textContent = '';
                        }
                    }
                });
            });
        }
        
        // 选择单元格
        function selectCell(row, col) {
            gameState.selectedCell = { row, col };
            renderSudokuGrid();
        }
        
        // 处理数字选择
        function handleNumberSelection(number) {
            if (gameState.selectedCell && !gameState.isCompleted) {
                const { row, col } = gameState.selectedCell;
                
                // 检查是否可以放置这个数字
                if (sudokuSolver.isValid(gameState.puzzle, row, col, number)) {
                    // 更新用户网格
                    gameState.userGrid[row][col] = number;
                    gameState.puzzle[row][col] = number;
                    
                    // 清除选择
                    gameState.selectedCell = null;
                    
                    // 重新渲染网格
                    renderSudokuGrid();
                    
                    // 检查是否完成
                    if (isPuzzleComplete()) {
                        // 使用requestAnimationFrame确保动画流畅
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                const completionMessage = document.getElementById('completion-message');
                                if (completionMessage) {
                                    completionMessage.classList.remove('hidden');
                                }
                            }, 500);
                        });
                    }
                } else {
                    // 无效移动的动画反馈 - 使用requestAnimationFrame确保动画效果
                    requestAnimationFrame(() => {
                        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('bg-accent/20');
                            setTimeout(() => {
                                cell.classList.remove('bg-accent/20');
                            }, 500);
                        }
                    });
                }
            }
        }
        
        // 检查谜题是否完成
        function isPuzzleComplete() {
            // 一次遍历同时检查是否填满和答案是否正确
            let isFilled = true;
            let isCorrect = true;
            
            for (let row = 0; row < 9 && (isFilled || isCorrect); row++) {
                for (let col = 0; col < 9 && (isFilled || isCorrect); col++) {
                    if (gameState.puzzle[row][col] === 0) {
                        isFilled = false;
                    } else if (gameState.puzzle[row][col] !== gameState.solution[row][col]) {
                        isCorrect = false;
                    }
                }
            }
            
            // 如果没有填满或答案不正确，返回false
            if (!isFilled || !isCorrect) {
                return false;
            }

            gameState.isCompleted = true;
            stopTimer();

            // 保存最佳成绩
            const now = new Date();
            const elapsedSeconds = Math.floor((now - gameState.startTime) / 1000);
            const level = gameState.currentLevel;

            if (!gameState.bestTimes[level] || elapsedSeconds < gameState.bestTimes[level]) {
                gameState.bestTimes[level] = elapsedSeconds;
                localStorage.setItem('sudokuBestTimes', JSON.stringify(gameState.bestTimes));
                updateBestTimeDisplay();
            }

            return true;
        }
        
        // 显示提示 - 性能优化版本
        function showHint() {
            if (gameState.hintsRemaining > 0 && !gameState.isCompleted) {
                // 缓存当前谜题引用以减少属性访问
                const currentPuzzle = gameState.puzzle;
                
                // 找到第一个空白单元格 - 使用更高效的循环结构和标签跳出
                let emptyCell = null;
                outerLoop: for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (currentPuzzle[row][col] === 0) {
                            emptyCell = { row, col };
                            break outerLoop;
                        }
                    }
                }
                
                if (emptyCell) {
                    const { row, col } = emptyCell;
                    const correctNumber = gameState.solution[row][col];
                    
                    // 填入正确数字
                    gameState.puzzle[row][col] = correctNumber;
                    gameState.userGrid[row][col] = correctNumber;
                    
                    // 减少提示次数
                    gameState.hintsRemaining--;
                    updateHintButton();
                    
                    // 使用requestAnimationFrame批量更新UI以减少重排重绘
                    requestAnimationFrame(() => {
                        renderSudokuGrid();
                        
                        // 使用setTimeout和requestAnimationFrame组合确保高亮动画流畅
                        setTimeout(() => {
                            requestAnimationFrame(() => {
                                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                                if (cell) {
                                    cell.classList.add('bg-secondary/30');
                                    
                                    // 高亮动画
                                    setTimeout(() => {
                                        requestAnimationFrame(() => {
                                            cell.classList.remove('bg-secondary/30');
                                        });
                                    }, 1500);
                                }
                            });
                        }, 50);
                    });
                    
                    // 检查是否完成
                    if (isPuzzleComplete()) {
                        gameState.isCompleted = true;
                        
                        // 使用requestAnimationFrame和setTimeout确保完成消息显示流畅
                        setTimeout(() => {
                            requestAnimationFrame(() => {
                                const completionMessage = document.getElementById('completion-message');
                                if (completionMessage) {
                                    completionMessage.classList.remove('hidden');
                                }
                            });
                        }, 500);
                    }
                }
            }
        }
        
        // 更新提示按钮
        function updateHintButton() {
            const hintButton = document.getElementById('btn-hint');
            hintButton.innerHTML = `<i class="fa fa-lightbulb-o mr-2"></i>提示 (${gameState.hintsRemaining})`;
            
            if (gameState.hintsRemaining === 0) {
                hintButton.classList.add('opacity-50', 'cursor-not-allowed');
                hintButton.disabled = true;
            } else {
                hintButton.classList.remove('opacity-50', 'cursor-not-allowed');
                hintButton.disabled = false;
            }
        }
        
        // 清除选择
        function clearSelection() {
            if (gameState.selectedCell) {
                const { row, col } = gameState.selectedCell;
                // 只有用户填入的数字可以清除
                if (gameState.userGrid[row][col] !== 0 && gameState.puzzle[row][col] !== 0) {
                    gameState.puzzle[row][col] = 0;
                    gameState.userGrid[row][col] = 0;
                }
                gameState.selectedCell = null;
                renderSudokuGrid();
            }
        }
    </script>
</body>
</html>
<!-- 内联一些必要的Font Awesome图标样式，以防CDN加载失败 -->
<style>
    .fa {
        display: inline-block;
        font: normal normal normal 14px/1 FontAwesome;
        font-size: inherit;
        text-rendering: auto;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    
    .fa-refresh:before { content: "\f021"; }
    .fa-check:before { content: "\f00c"; }
    .fa-lightbulb-o:before { content: "\f0eb"; }
    .fa-volume-up:before { content: "\f028"; }
    .fa-volume-off:before { content: "\f026"; }
    .fa-sun-o:before { content: "\f185"; }
    .fa-moon-o:before { content: "\f186"; }
    .fa-home:before { content: "\f015"; }
    .fa-info-circle:before { content: "\f05a"; }
    .fa-times:before { content: "\f00d"; }
    .fa-chevron-left:before { content: "\f053"; }
    .fa-chevron-right:before { content: "\f054"; }
    .fa-difficulty-easy:before { content: "\f00c\f00c\f00c"; }
    .fa-difficulty-medium:before { content: "\f00c\f00c\f096"; }
    .fa-difficulty-hard:before { content: "\f00c\f096\f096"; }
</style>